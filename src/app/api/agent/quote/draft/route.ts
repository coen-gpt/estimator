import { NextResponse } from "next/server";
import { getValidAccessToken } from "@/lib/token";
import { jobberGraphQL } from "@/lib/jobber";

export const runtime = "nodejs";

type LineItemInput = {
  name: string;
  description?: string;
  quantity: number;
  unitPrice: number;
};

type DraftQuoteRequest = {
  connectionId: string;
  clientName: string;
  propertyAddress: string;
  lineItems: LineItemInput[];
  notes?: string;
};

function validateBody(body: unknown): DraftQuoteRequest {
  if (!body || typeof body !== "object") {
    throw new Error("Request body must be JSON object");
  }

  const input = body as Partial<DraftQuoteRequest>;

  if (!input.connectionId) throw new Error("connectionId is required");
  if (!input.clientName) throw new Error("clientName is required");
  if (!input.propertyAddress) throw new Error("propertyAddress is required");
  if (!Array.isArray(input.lineItems) || input.lineItems.length === 0) {
    throw new Error("lineItems must be a non-empty array");
  }

  return {
    connectionId: input.connectionId,
    clientName: input.clientName,
    propertyAddress: input.propertyAddress,
    lineItems: input.lineItems,
    notes: input.notes
  };
}

const CREATE_QUOTE_MUTATION = /* GraphQL */ `
  mutation CoenGPTCreateQuoteDraft($input: QuoteCreateInput!) {
    quoteCreate(input: $input) {
      quote {
        id
        quoteNumber
        status
      }
      userErrors {
        message
        path
      }
    }
  }
`;

export async function POST(req: Request) {
  try {
    const body = validateBody(await req.json());
    const accessToken = await getValidAccessToken(body.connectionId);

    // TODO: Map `clientName` and `propertyAddress` to concrete Jobber client/property IDs before production use.
    const variables = {
      input: {
        title: `AI Draft - ${body.clientName}`,
        note: body.notes ?? "Generated by CoenGPT estimator",
        lineItems: body.lineItems.map((item) => ({
          name: item.name,
          description: item.description ?? "",
          quantity: item.quantity,
          unitCost: item.unitPrice
        }))
      }
    };

    const gqlResult = await jobberGraphQL<
      {
        quoteCreate?: {
          quote?: { id: string; quoteNumber?: string; status?: string };
          userErrors?: Array<{ message: string; path?: string[] }>;
        };
      },
      { input: Record<string, unknown> }
    >(accessToken, CREATE_QUOTE_MUTATION, variables);

    if (gqlResult.errors?.length) {
      return NextResponse.json(
        {
          ok: false,
          status: "graphql_error",
          errors: gqlResult.errors,
          hint: "Check Jobber schema fields for quoteCreate and adjust input mapping."
        },
        { status: 400 }
      );
    }

    const payload = gqlResult.data?.quoteCreate;
    if (payload?.userErrors?.length) {
      return NextResponse.json(
        {
          ok: false,
          status: "user_error",
          errors: payload.userErrors
        },
        { status: 400 }
      );
    }

    if (!payload?.quote?.id) {
      return NextResponse.json(
        {
          ok: true,
          status: "stub_success",
          quoteId: null,
          message: "Mutation executed but quote id missing; verify schema and field names."
        },
        { status: 202 }
      );
    }

    return NextResponse.json({
      ok: true,
      status: payload.quote.status ?? "draft",
      quoteId: payload.quote.id,
      quoteNumber: payload.quote.quoteNumber ?? null
    });
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unexpected server error";
    return NextResponse.json(
      {
        ok: false,
        error: message
      },
      { status: 400 }
    );
  }
}
